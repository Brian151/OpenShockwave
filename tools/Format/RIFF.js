/*
	JavaScript implementation of the Rescource Interchange File Format
	This class is only meant to parse the basic features of the format
	Implementation of any specific features/formats is not covered.
	The only deviations this takes from the 'standard' format is:
		A) Support for the RIFX / XFIR meta-formats
		B) [possible planned future] IFF format
			It's not all that different than RIFF/RIFX, except:
				A) allows nested FORMs [this parser doesn't adhere to RIFF not supporting this, anyways]
				B) the LIST top-level chunk, and PROP chunk
					A) Basically, allows different forms to share data
					B) Not actually a bad idea, but there are some caveats
					C) Details: http://1fish2.github.io/IFF/IFF%20docs%20with%20Commodore%20revisions/EA%20IFF%2085.pdf
						(specifically pages 19,22)

	TO-DO:
		Better document the code...
		More effective indexing strategy, it'll fail to fully index many real-world examples, like PNG
*/
var RIFF = function(data) {
	this.view = new DataView(data);
	this.formats = ["RIFF","RIFX","XFIR"];
	/*
		ENDIANESS OF : fourCC , length
		(not sure if right, probably isn't entirely)
		B[ig] L[ittle]
	*/
	this.ends = [
		["B","L"],
		["B","B"],
		["L","L"],
	];
	this.format = 0;
	this.index = []; //map of ALL chunks in the file, not generated by default
	this.returnType = "binary";
	this.length = this.view.byteLength;
	/*
		NEEDS SERIOUS WORK...
	*/
}
RIFF.prototype.getChunkAt = function(offset,getForm) {
	/*
		WARNING !
		This function can grab...a lot
		Calling it on particularly large sections *could* cause performance or
		stability issues!
	*/
	var head = this.getFourCCAt(offset);
	var length = this.getUIntAt(offset + 4);
	// console.log(head + " : 0x" + length.toString(16));
	var data = this.getDataBytes(offset + 8,length);
	if (getForm) {
		var type = this.getFourCCAt(offset += 8);
		// console.log(type);
		head += " (" + type + ")";
	}
	return [head,data];
}
RIFF.prototype.getFourCCAt = function(offset) {
	var off = offset || 0;
	var end = this.ends[this.format][0] == "L";
	var str = [];
	var e = false;
	for (var i=0; i < 4; i++) {
		var curr = this.getUByteAt(off + i);
		if (curr >= 32) {
			str.push(String.fromCharCode(curr));
		} else {
			e = true;
			str = ["E","R","R"," "];
			break;
		}
	}
	if (end && !e) 
		str.reverse();
	out = str.join("");
	return out;
}
RIFF.prototype.setFourCCAt = function(offset,fourCC) {
	if (typeof fourCC == "string" && fourCC.length == 4) {
		var str = fourCC.split("");
		var end = this.ends[this.format][0] == "L";
		if (end)
			str.reverse();
		for (var i=0; i < 4; i++) {
			var curr = str[i].charCodeAt(0);
			var currS = str[i];
			if (curr >= 32 && curr <= 255) {
				this.setUByteAt(offset + i,curr);
			} else {
				this.setUByteAt(offset + i,32); //space
				console.log("WARNING! : " + currS + " | " + curr + " is not a valid printable ASCII character! space written to fourCC at offset " + this.toHex(offset,"U32") + " | " + this.toHex(offset + i,"U32"));
			}
		}
	}
}
RIFF.prototype.getUIntAt = function(offset,ends) {
	var off = offset || 0;
	var end = false;
	switch (ends) {
			case 1:
				end = false;
				break;
			case 2:
				end = true;
				break;
			case 0:
			default:
				end = this.ends[this.format][1] == "L";
	}
	return this.view.getUint32(off,end);
}
RIFF.prototype.setUIntAt = function(offset,value) {
	var off = offset || 0;
	var end = false;
	switch (ends) {
			case 1:
				end = false;
				break;
			case 2:
				end = true;
				break;
			case 0:
			default:
				end = this.ends[this.format][1] == "L";
	}
	return this.view.setUint32(off,value);
}
RIFF.prototype.getUShortAt = function(offset,ends) {
	var end = ends || false;
	return this.view.getUint16(offset,end);
}
RIFF.prototype.setUShortAt = function(offset,value,ends) {
	var end = ends || false;
	return this.view.setUint16(offset,value,end);
}
RIFF.prototype.getUByteAt = function(offset) {
	return this.view.getUint8(offset);
}
RIFF.prototype.setUByteAt = function(offset,value) {
	return this.view.getUint8(offset,value);
}
RIFF.prototype.getIntAt = function(offset,ends) {
	var end = ends || false;
	return this.view.getInt32(offset,end);
}
RIFF.prototype.setIntAt = function(offset,ends) {
	var end = ends || false;
	return this.view.setInt32(offset,end);
}
RIFF.prototype.getShortAt = function(offset,ends) {
	var end = ends || false;
	return this.view.getInt16(offset,end);
}
RIFF.prototype.setShortAt = function(offset,ends) {
	var end = ends || false;
	return this.view.setInt16(offset,end);
}
RIFF.prototype.getByteAt = function(offset) {
	return this.view.getInt8(offset);
}
RIFF.prototype.setByteAt = function(offset,value) {
	return this.view.setInt8(offset,value);
}
RIFF.prototype.getFloatAt = function(offset,ends) {
	var end = ends || false;
	return this.view.getFloat32(offset,end);
}
RIFF.prototype.setFloatAt = function(offset,value,ends) {
	var end = ends || false;
	return this.view.setFloat32(offset,value,end);
}
RIFF.prototype.getDoubleAt = function(offset,ends) {
	var end = ends || false;
	return this.view.getFloat64(offset,end);
}
RIFF.prototype.setDoubleAt = function(offset,value,ends) {
	var end = ends || false;
	return this.view.setFloat64(offset,value,end);
}
RIFF.prototype.toHex = function(num,type) {
	var out = num.toString(16)
	switch (type) {
		case "U16" :
			var len = 16 / 4;
			break;
		case "U8" :
			var len = 8 / 4;
			break;
		case "U32" :
		default :
			var len = 32 / 4;
	}
	if (out.length < len) {
		var pad = len - out.length;
		for (var i=0; i < pad; i++) {
			out = "0" + out;
		}
	} else if (out.length > len) {
		console.log("ERROR HEX-ENCODING " + num + " as " + type + " !");
		out = this.toHex(0,type);
	}
	return out;
}
RIFF.prototype.setFormat = function (f) {
	if (!f) {
		f = "RIFF"; // defaults to RIFF
	}
	for (var i=0 ; i < this.formats.length; i++) {
		var curr = this.formats[i];
		if (curr == f) {
			this.format = i;
			break;
		}
	}
}
RIFF.prototype.getDataBytes = function(offset,length) {
	var off = offset;
	var l = length;
	var out = new Uint8Array(l);
	for (var i=0; i < l; i++) {
		out[i] = this.getUByteAt(off + i);
	}
	return out;
}
RIFF.prototype.indexChunks = function() {
	for (var i=0; i < this.length; i+=0) {
		var ID = this.getFourCCAt(i);
		var len = this.getUIntAt(i + 4);
		var offset = i;
		this.index.push([ID,offset]);
		len += (len % 2) // RIFF is byte-aligned to 2 bytes! modulus of <x> % 2 is either 1 or 0
		if (ID == "RIFF" || ID == "RIFX" || ID == "INFO") {
			len = 0;
			if (ID == "RIFF" || ID == "RIFX")
				len += 4; // skip formtype!
		}
		i += len + 8;
	}
}