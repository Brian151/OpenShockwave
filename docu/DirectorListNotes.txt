example pref:
[
	#ID: 1, 
	#company: 0, 
	#type:"SMART" , 
	#icon:1, 
	#name:"SMART HQ", 
	#path:[753,792,775],
	#state:#WIN, 
	#data:[#security:1, #reward:400, #creditItems:0] 
]
JSON struct:
obj
{
	attr [num]
	attr [num]
	attr [str]
	attr [num]
	attr [str]
	attr [arr]
	attr [state/pointer]
	attr [obj]
		{
			attr [num]
			attr [num]
			attr [num]
		}
}
rules:
"[" ... "#" = object >> "#" .. ":" AND NOT nested = object
"#" ... ":" = property >> same
"#" = 'symbol' >> same
"[" ... "]" = array >> "[" "]" AND NOT CHILD ATTRIBUTES
":" ... <number, won't have quotes> = number >> same
":" ... <string, WILL have quotes> = string >> same
whitespace = ignore, except when inside string >> same
"," = delimiter, unless inside string >> same
""" = string control char >> new
"\" = escape character, not observed thus far >> new

http://www.deansdirectortutorials.com/Lingo/lists.htm
linear list = [0,1,[],"stuff",#stuff] (essentially, an array [0,1,[],"stuff","#stuff"])
property list = [#foo:#bar,#tuna:#fish] (essentially, an object {foo:"bar",tuna:"fish"})

[] = list (basically an array)
#prop: = property (basically a named list element)
#value = symbol (
	name == value, 
	supposed to have the speed of numbers, 
	and the readability of a string, or something like that
	the value it holds is its name
	Not really sure there's any way to emulate this,
	I can't wrap my head around how these actually would work.
	They're supposed to be faster than using a string, though...
	(actually, bytecode docus suggests this is just like how objects work in JSON/JS)
)

current re-implementation/conversion status:
one horribly broken tool that can even crash the browser