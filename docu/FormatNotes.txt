SHOCKWAVE FORMAT (general internal workings):

RIFX
{
	Uint32 chunklength
	FourCC formtype 
	(
	"MV93" for DXR and DIR 
	"FGDM" for DCR
	"LPPA" for Projector RIFX container (see Projector Notes)
	)
	data (entire file, minus chunkID & chunklength), chunklength bytes long
}

sub-chunks:

imap
{
	chunklength
	8 bytes unknown
	4 bytes mapOffset 
	*points to the currently valid mapp chunk
	as it turns-out, re-saving a .dir just appends data, including
	a new mmap chunk (o...k...)*/
}

mmap
{
	length
	data (first 0x18 bytes are unknown)
	/*
	following those bytes is a list of chunks
	this is the mapping table
	*/
	entry
	{
		fourcc chunkID
		uint32 length (not sure why include this, since these entries are nothing but pointers to the chunk)
		unit32 offset
		//remaining 8 bytes are unknown, and always seem to be set to 0
		//in total, each entry is 0x14 in length
	}

}

KEY*
{
	length
	data
	{
		Uint16 unknown (only 0x0C observed, possibly the length of each entry or the chunk header?)
		Uint16 unknown (only 0x0C observed, possibly the length of each entry or the chunk header?)
		Uint32 sectionCount
		Uint32 castCount (just a guess, need to verify)
		entry {
			/*
				dealing with spybotics suggests there's something more that goes on with
				the ID/index lookup. It could be a version-specific quirk? Using the exclusive
				IDs (ignoring free) is causing problems... and recent research with CAS* indicates certain values
				point to freespace (entries of solid 0x00, e.g. NULL) in the mapping table. Also noteworthy
				is the JavaScript parser at this time is unable to successfully parse the KEY* section in
				spybotics, and a majority of the CASt sections are somehow being skipped...
				This needs to be solved pronto, the castlib cannot be reconstructed without this data!
			*/
			Uint32 sectionIdex (the index of the section in the mmap excluding "free" sections, they are to be ignored)
			Uint32 castIndex (the index of the related CASt section in the mmap excluding "free" sections, they are to be ignored)
			fourcc chunkID
		}
		
	}
}

free
(
	length always 0
	//but entire entry is always 0x14 in size
	//these are basically just free space, and seem to serve no real purpose
	//this part of docu is now outdated
)

XMED
(
	length
	followed immediatly by data <length> in size
	// contains Xtra Media, any media requiring an Xtra to play, such as SWA requiring the SWA Decompression Xtra or SWF requiring the FLash Asset Xtra etc.
)

snd 
{
	length (sometimes 0)
	// sometimes the length is 0 and it trails SWA audio.
	// in that scenario the XMED and snd are linked to the same CASt in the KEY* section so the cast member is classed as a sound even though it requires an Xtra to play
	// other times it contains raw PCM streams which GoldWave can import, and probably Audacity as well.
	// observed: Raw PCM unsigned 8 bit, 11025 Hz, 88 kbps, mono (for the door opening sound in MYLK)
}

ediM
{
	length
	data <length> in size
	//contains SWA audio-
	//further analysis shows this contains other data/file types as well...further research required
}

BITD
{
	length
	data
	//bitmap data, but i am unsure how to parse them
	// Can be Standard (probably uncompressed) or JPEG
}

CASt
{
	length
	<length> bytes data
		header{
			Uint32 [big-end] castMemberType
			(
				0x01 : bitmap
				0x02 : film loop
				0x04 : palette
				0x06 : audio
				0X07 : button
				0x08 : vector shape
				0x0B : script
				0x0F : flash,font,text,W3D //The common link between all is the requirement of Xtras to use these
			)
			Uint32 [big end] length2 //from 0x14 to specificData
			Uint32 [big-end] specificDataLen
			0x14 bytes skipThis {
				Uint32 [big-end] skipSize? (always 0x14)
				0x10 bytes unknownData (does vary, but purpose unknown)
			}
			Uint16 [big-end] offsetTableLen
			<offsetTableLen> Uint32Array offsetTable {
				Uint32 [big-end] offsetX //see formatNotes_CASt_fields
			}
			Uint32 [big end] finalDataLen
			<finalDataLen> metaData
			{
				//comprised of various fields...
				//see formatNotes_CASt_fields
			}
		}
		<specificDataLength> specificData{
			/*
			These vary a lot, but they do seem to have an absolute structure and order
			*/
			paletteData {
				//nothing yet found, every palette observed thus far hasn't had any
			}
			bitmapData {
				//still trying to understand this one...
				4 bytes unknown
				2 bytes unknown
				Uint16 width
				Uint16 height
				Uint32 constant1 (1) //1 is so far, only observed value...
				4 bytes unknown
				Uint16 regPointX
				Uint16 regPointY
				2 bytes unknown
				4 bytes palleteID //? still needs more research, not even sure how director actually links palettes
			}
			scriptData {
				Uint16 [big-end] scriptType
				(
					00 01 : behavior
					00 03 : movie
					00 07 : parent
				)
			}
		}
	
	/*cast member header/metadata
	this chunk is proving particularly difficult to fully decypher, and recent efforts have 
	shown the available fields vary quite largely depending on any number of factors.
	This can be attributed to both the type of cast member, and even if a file has been
	Dir-Opened vs. being the genuine DIR source movie/document
	*/
}

CAS*
{
	length
	data {
		/*
		a Unit32 array, each value is an indice according to the mapping table...
		The indeces should all point to CASt sections
		*/
	}
	/*
		This is a cast, or rather, a cast association table. This contains the neccesarry data to group
		CASt sections into a complete cast. It does not contain the name, however. The cast name would be found 
		in the MCsl section. External casts do not have a CAS* table, probaby because they do not need one with
		their data being stored in separate files.
	*/
}

CLUT
{
	length (ALWAYS divisible by 6)
	/*
	color palettes,
	each CLUT actually contains 2, and they're combined in a somewhat odd manner...
	Or, each color value has some extra data attached.
	Regardless, the reasons for the three extra bytes per entry is a mystery for the time being.
	Other than that, the data is an array of RGB24 colors
	*/
	<length / 6> entries/data {
		byte red
		byte red2
		byte green
		byte green2
		byte blue
		byte blue2
	}
}

MCsL
{
	length
	4 bytes unknown (0x0c)
	4 bytes castCount
	2 bytes short unknown (4)
	4 bytes arraySize
	<arraySize * 4> bytes unknownDataEntries (one entry per cast) {
		4 bytes unknown
		4 bytes unknown
		4 bytes unknown
		4 bytes unknown
		/*
			This could be similar to the length tables found in CASt sections...
			Unlike the CASt length tables, the absolute length of this has been
			determined, it's (arraySize * 4)
		*/
	}
	4 bytes castEntriesLength
	<castCount> entries
	{
		byte nameLength
		<nameLength> bytes name
		1 byte null
		2 bytes short preloadSettings (0:when needed, 1: after frame one, before frame one)
		2 bytes short storageType (0:external,1:internal)
		[1 byte unknown] (if external cast)
		2 bytes short membersCount
		2 bytes short numID
		byte unknown (4)
		byte unknown (0)
		/*
		This might be slightly innaccurate...
		It's also somehow missing a value for preload settings
		*/
	}
	/*
	cast list
	all attempts to figure-out how these actually link to a cast have been fruitless
	only remaining option thus far is that this happens automatically, meaning
	the cast names and their member lists(if present) are stored in the same
	order
	*/
	/*
	External cast files (CST,CCT,CXT) seem to not have these. It makes sense, because external casts only contain ONE
	cast: themselves.
	*/
}

XTRl
{
	Uint32 length
	4 bytes unknown
	Uint32 [big-end] xtraCount
	<xTraCount> entries {
		Uint32 [big end] length
		<length> bytes data
		{
			//needs more research
			0x22 bytes unknown (values seem fairly consistent)
			Uint32 [big-end] length2
			<length2> bytes data
			{
				2 bytes unknown
				Uint8 nameLength
				<nameLength> bytes name
				3 bytes unknown
				Uint8 pathLength
				<pathLength> bytes path/url
				byte unknown (0x00)
			}
		}
	}
	[one extra padding byte if odd length]
	/*
	Xtra library/linkage...
	Lists required Xtras to play the movie
	*/
}

shockwave format types:
DXR : 'protected'
DCR : compressed (via zlib)
DIR : uncompressed + unprotected
CXT : 'protected'
CCT : compressed (via zlib)
CST : uncompressed + unprotected

purposes:
D*R : movie, runs stand-alone, may load C*T's as dependencies
C*T : 
(
external "cast" , basically an external library of stuff. 
D*R's are made of multiple internal casts, and will attempt to
load external casts if any have been linked.
Some movies can play without the external casts
External casts are essentially the same structure as a movie,
except they only contain one cast, and cannot run as a stand-alone application.
)

extra notes:
Spybotics, does not actually require its external casts to run.
However, this might impact the music*

*All remaining copies/archives of Spybotics: The Nightfall Incident
do not have the sound_level_<1-5>.cct, and the snd_netload_<1-5>.cct files.
It's quite possible official releases never actually did use them.
the sound_level_<x> files are all empty, and the snd_netload_<x> files
contain alternative soundtracks. These tracks probably are for databattles.