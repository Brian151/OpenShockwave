RIFF: http://www.johnloomis.org/cpe102/asgn/asgn1/riff.html

(
basically, 
4 bytes chunkID
4 bytes chunklength
<chunklength> bytes chunkdata (plus extra byte if not even length)
)

special chunks (like "RIFF") have one extra field
(
4 bytes chunkID
4 bytes chunklength
4 bytes formtype ("WAVE", for example)
<chunklength> bytes chunkdata (plus extra byte if not even length)
	(
	sub-chunks
	)
)

RIFX:
network byte order / big-endian

XFIR:
network byte order / big-endian
EXCEPT
(
chunkID
chunklength
formtype (???)
), which are little-endian

SHOCKWAVE FORMAT:

RIFFX
{
Uint32 chunklength
FourCC formtype 
	(
	"MV93" for DXR and DIR 
	"FGDM" for DCR
	"LPPA" for Projector RIFX container (see Projector Notes)
	)
	data (entire file, minus chunkID & chunklength), chunklength bytes long
}

sub-chunks:
Fver
{
	// Appears only in DCR.
	1 byte [Uint8? Varint?]! chunkLength!!
	5 bytes unknown (binary representation of version, maybe?)
	String fileVersion (written as byte length followed by string)
	/*
	! type cannot be exactly verified, no observed Fver has yet reason to
	be a very large size. version numbers are usually small in size, even
	when written as plaintext. However, DCR does use varints for numbers, a lot...
	See ABMP for explanation of varints
	
	!! This only seems to make sense so far, but no counter-example has yet been observed.
	It logically makes sense, because whatever is reading the file NEEDS to know the size
	of a given chunk. Zlib is no compression, and would likely fail catostrophically if
	it didn't know the size of what it is supposed to be decompressing. A hacker or hacker tool
	could simply sniff for headers (in this case, RIFF FourCC's) , however, this is potentially
	error-prone. No sane programmer uses guesswork on a file format, especially a complex one.
	The length of a given block/section generally is declared explicitly, somewhere. Sometimes,
	it is declared in multiple places. 
	*/
}

Fcdr
{
	// Appears only in DCR.
	// contains ziplib compressed data
	// is just strings for if there was an error like "Missing Xtra" etc.
}

ABMP
{
	// Appears only in DCR.
	/*
	Similar to mmap, but using varints
	
	A varint is an int that can be any number of bytes long.
	This is accomplished by the first bit of every byte
	representing whether the next byte is part of the number
	or not. For example:
	
	
	0x19 is the same in both representations.
	
	Normal:    00011001
	As varint: 00011001
	
	
	0xE1 is different as a varint
	
	Normal:             1110 0001
	As varint: 10000001 0110 0001
	
	Notice how with 0xE1, what is normally the first bit
	became the last bit of the first byte, because in
	a varint, the first bit of each byte says whether
	or not another byte will follow.
	
	With that said, the format of ABMP is as follows:
	varint id
	varint offset // this refers to the FGEI section
	varint compressed_size
	varint decompressed_size
	varint repr_mode (not sure what this does, just the name according to Schockabsorber)
	fourcc chunkID
	*/
}

FGEI
{
	// Appears only in DCR.
	/*
	Compressed zlib data.
	Contains all the sections referenced in ABMP.
	Note that this doesn't use RIFX at all, it depends
	on the ABMP section to lay it out, so
	there's no redundant information like how mmap
	repeats the name and length of each section.
	*/
}

imap 
{
	chunklength
	8 bytes unknown
	4 bytes mapOffset 
	*points to the currently valid mapp chunk
	as it turns-out, re-saving a .dir just appends data, including
	a new mmap chunk (o...k...)*/
}

mmap
{
	/* in DCR, this is the contents of the second extracted file, and describes the third extracted file, but it seems to be arranged differently, where the list of chunks is seperated by null terminator 0xFFFFFF7F, and the section name starts with 0x00, I can't see where the length comes from */
	length
	data (first 0x18 bytes are unknown)
	/*following those bytes is a list of chunks
	That's where this gets good
	this is the mapping table*/
	entry
	{
		fourcc chunkID
		uint32 length (not sure why include this, since these entries are nothing but pointers to the chunk)
		unit32 offset
		//remaining 8 bytes are unknown, and always seem to be set to 0
		//in total, each entry is 0x14 in length
	}

}

KEY*
{
	length
	data
	{
		Uint16 unknown (only 0x0C observed, possibly the length of each entry or the chunk header?)
		Uint16 unknown (only 0x0C observed, possibly the length of each entry or the chunk header?)
		Uint32 sectionCount
		Uint32 castCount (just a guess, need to verify)
		entry {
			/*
				dealing with spybotics suggests there's something more that goes on with
				the ID/index lookup. It could be a version-specific quirk? Using the exclusive
				IDs (ignoring free) is causing problems... and recent research with CAS* indicates certain values
				point to freespace (entries of solid 0x00, e.g. NULL) in the mapping table. Also noteworthy
				is the JavaScript parser at this time is unable to successfully parse the KEY* section in
				spybotics, and a majority of the CASt sections are somehow being skipped...
				This needs to be solved pronto, the castlib cannot be reconstructed without this data!
			*/
			Uint32 sectionIdex (the index of the section in the mmap excluding "free" sections, they are to be ignored)
			Uint32 castIndex (the index of the related CASt section in the mmap excluding "free" sections, they are to be ignored)
			fourcc chunkID
		}
		
	}
}

free
(
	length always 0
	//but entire entry is always 0x14 in size
	//these are basically just free space, and seem to serve no real purpose
	//this part of docu is now outdated
)

XMED
(
	length
	followed immediatly by data <length> in size
	// contains Xtra Media, any media requiring an Xtra to play, such as SWA requiring the SWA Decompression Xtra or SWF requiring the FLash Asset Xtra etc.
)

snd 
{
	length (sometimes 0)
	// sometimes the length is 0 and it trails SWA audio.
	// in that scenario the XMED and snd are linked to the same CASt in the KEY* section so the cast member is classed as a sound even though it requires an Xtra to play
	// other times it contains raw PCM streams which GoldWave can import, and probably Audacity as well.
	// observed: Raw PCM unsigned 8 bit, 11025 Hz, 88 kbps, mono (for the door opening sound in MYLK)
}

ediM
{
	length
	data <length> in size
	//contains SWA audio
}

BITD
{
	length
	data
	//bitmap data, but i am unsure how to parse them
	// Can be Standard (probably uncompressed) or JPEG
}

CASt
{
	length
	<length> bytes data
		header{
			Uint32 [big-end] castMemberType
			(
				0x01 : bitmap
				0x02 : film loop
				0x04 : palette
				0x06 : audio
				0X07 : button
				0x08 : vector shape
				0x0B : script
				0x0F : flash,font,text [why use same number???]
			)
		}
		fields {
			/*
			My mistake was in assuming two things:
			1. All CASt have the same fields
			2. Fields always appear in the same order
			This is evidentally, not the case...
			*/
			name {
			byte nameLength
			<nameLength> bytes name
			}
			UTCdate dateCreated
			UTCdate dateLastModified
			imageCompression {
				byte compression [0xFB : movie setting, 0XFE : standard, 0xFD: JPEG]
				byte compressionQuality [default: 0x50 (80%)] (ONLY used if JPEG, but always present)
				Uint16 [big-end] unknown
			}
			4 bytes unknown (4e 2f 41 00)
		}
		specificData{
			/*
			These vary a lot, but they do seem to have an absolute structure and order
			*/
			bitmapData {
				4 bytes unknown
				2 bytes unknown
				Uint16 width
				Uint16 height
				//not entirely sure from here on out...
				4 bytes unknown (01 00 00 00)
				4 bytes unknown
				4 bytes unknown
				4 bytes unknown
				2 bytes unknown
			}
			scriptData {
				Uint16 scriptType
				(
					00 01 : behavior
					00 03 : movie
					00 07 : parent
				)
			}
		}
	
	/*cast member header/metadata
	this chunk is proving particularly difficult to fully decypher, and recent efforts have 
	shown the available fields vary quite largely depending on any number of factors.
	This can be attributed to both the type of cast member, and even if a file has been
	Dir-Opened vs. being the genuine DIR source movie/document
	*/
}

CAS*
{
	length
	data {
		/*
		a Unit32 array, each value is an indice according to the mapping table...
		The indeces should all point to CASt sections
		*/
	}
	/*
		This is a cast, or rather, a cast association table. This contains the neccesarry data to group
		CASt sections into a complete cast. It does not contain the name, however. The cast name would be found 
		in the MCsl section. External casts do not have a CAS* table, probaby because they do not need one.
	*/
}

CLUT
{
	length
	data
	//color palettes? , probably RGB24, still researching...
	//data is simply an array of 24-bit RGB colors, but more research is needed
}

MCsL
{
	length
	4 bytes unknown (0x0c)
	4 bytes castCount
	2 bytes short unknown (4)
	4 bytes arraySize
	<arraySize * 4> bytes unknownDataEntries (one entry per cast) {
		4 bytes unknown
		4 bytes unknown
		4 bytes unknown
		4 bytes unknown
		/*
			This could be similar to the length tables found in CASt sections...
			Unlike the CASt length tables, the absolute length of this has been
			determined, it's (arraySize * 4)
		*/
	}
	4 bytes castEntriesLength
	<castCount> entries
	{
		byte nameLength
		<nameLength> bytes name
		1 byte null
		2 bytes short preloadSettings (0:when needed, 1: after frame one, before frame one)
		2 bytes short storageType (0:external,1:internal)
		[1 byte unknown] (if external cast)
		2 bytes short membersCount
		2 bytes short numID
		byte unknown (4)
		byte unknown (0)
		/*
		This might be slightly innaccurate...
		It's also somehow missing a value for preload settings
		*/
	}
	/*
	cast list
	all attempts to figure-out how these actually link to a cast have been fruitless
	only remaining option thus far is that this happens automatically, meaning
	the cast names and their member lists(if present) are stored in the same
	order
	*/
}

XTRl
{
	Uint32 length
	4 bytes unknown
	Uint32 [big-end] xtraCount
	<xTraCount> entries {
		Uint32 [big end] length
		<length> bytes data
		{
			//needs more research
			0x22 bytes unknown (values seem fairly consistent)
			Uint32 [big-end] length2
			<length2> bytes data
			{
				2 bytes unknown
				Uint8 nameLength
				<nameLength> bytes name
				3 bytes unknown
				Uint8 pathLength
				<pathLength> bytes path/url
				byte unknown (0x00)
			}
		}
	}
	[one extra padding byte if odd length]
	/*
	Xtra library/linkage...
	Lists required Xtras to play the movie
	*/
}

shockwave format types:
DXR : protected/encrypted
DCR : compressed (via zlib???)
DIR : doesn't seem to be encrypted or compressed
CXT : protected/encrypted
CCT : compressed
CST : nothing special... 

purposes:
D*R : movie, runs stand-alone, may load C*T's as dependencies
C*T : 
(
external "cast" , basically an external library of stuff. 
D*R's are made of multiple internal casts, and will attempt to
load external casts if any have been linked.
Some movies can play without the external casts
External casts are essentially the same structure as a movie,
except they only contain one cast, and cannot run as a stand-alone application.
)

extra notes:
Spybotics, does not actually require its external casts to run.
However, this might impact the music*

*All remaining copies/archives of Spybotics: The Nightfall Incident
do not have the sound_level_<1-5>.cct, and the snd_netload_<1-5>.cct files.
It's quite possible official releases never actually did use them.
the sound_level_<x> files are all empty, and the snd_netload_<x> files
contain alternative soundtracks. These tracks probably are for databattles.