example pref:
[
	#ID: 1, 
	#company: 0, 
	#type:"SMART" , 
	#icon:1, 
	#name:"SMART HQ", 
	#path:[753,792,775],
	#state:#WIN, 
	#data:[#security:1, #reward:400, #creditItems:0] 
]
JSON struct:
obj
{
	attr [num]
	attr [num]
	attr [str]
	attr [num]
	attr [str]
	attr [arr]
	attr [state/pointer]
	attr [obj]
		{
			attr [num]
			attr [num]
			attr [num]
		}
}
rules:
"[" ... "#" = object >> "#" .. ":" AND NOT nested = object
"#" ... ":" = property >> same
"#" = 'symbol' >> same
"[" ... "]" = array >> "[" "]" AND NOT CHILD ATTRIBUTES
":" ... <number, won't have quotes> = number >> same
":" ... <string, WILL have quotes> = string >> same
whitespace = ignore, except when inside string >> same
"," = delimiter, unless inside string >> same
""" = string control char >> new
"\" = escape character, not observed thus far >> new

update on format:
stumbled upon a preview of a book explaining how to use Director 8
[] = list (basically an array)
#prop: = property (basically a named list element)
#value = symbol (
name == value, 
supposed to have the speed of numbers, 
and the readability of a string, or something like that
the value it holds is its name
Not really sure there's any way to emulate this,
I can't wrap my head around how these actually would work.
They're supposed to be faster than using a string, though...
)
Really, this doesn't change that the format is definitely similar to JSON.
But, it's a more accurate interpretation of the format.
It might impact the process for how these are converted to JSON, though.
everything may just become an array, and i'll add code for reading from that array.